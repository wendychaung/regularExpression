# 正则表达式

```
g global全文搜索匹配(不添加代表搜索到第一个停止)

i ignore Case忽略大小写，默认是大小写敏感

m multiline多行搜索

lastIndex最后一个字符的下一个位置，下一次搜索的开始位置

source 文本字符串
```

**原义文本字符**

**元字符（有特殊含义的非字母字符）**
```
\t 水平制表符

\x0B 垂直tab而已

\v 垂直制表符

\n 换行符

\r 回车符

\0 空字符

\f 换页符
```

**[]来构造类**

**^ 取反** 在类中，表示取反

**范围类[a-z]** 如果需要匹配"-"，就写成[a-z-]

**预定义类**
```
. == [^\r\n] 除了回车换行意外事件的所有字符

\d ==[0-9] 数字字符

\D ==[^0-9] 非数字字符

\s ==[\t\r\x0B\n\f] 匹配任何不可见字符，

\S ==[^\t\r\x0B\n\f] 非空字符串

\w ==[a-zA-Z_0-9] 单词字符，包括大小写字母，数字，下划线

\w ==[^a-zA-Z_0-9] 非单词字符
```

**边界**

```
^ 以**开始

\b 单词边界

$ 以***结束

\B 非单词边界
```

**量词**

```
？最多出现一次

+ 至少出现一次

* 出现任意次 

{n} 出现n次

{n,m}出现n-m次

{n,} 至少出现n次
```

**贪婪模式** 尽可能多的匹配

**非贪婪模式** 在量词后加上？

**分组** 用()分组，可以让量词作用于分组

**或** 使用|可以实现

**分组捕获** 可以$来代替对分组内进行捕获

**忽略分组** 在分组内加上 ?:

**前瞻** 正向前瞻 exp(?=assert);负向前瞻 exp(?!assert)

**test 判断字符串是否匹配正则表达式** 如果加g 会存储lastIndex

**exec 返回数组**
没有时，返回null
第一项是返回相匹配的文本
第二项 返回子表达式匹配的文本

**search 检索与正则表达式匹配的字符串** 返回结果为第一个匹配的index，没有为-1 **不支持g**

**match** 检索与正则表达式匹配的字符串，**g对结果影响很大**
没有匹配时，返回null
非全局调用时，与exec相同，但全局调用时，没有index

**split 可以使用正则表达式**

**replace 返回并替换**